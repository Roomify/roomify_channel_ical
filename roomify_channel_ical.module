<?php

/**
 * @file
 */

use Roomify\Bat\Calendar\Calendar;
use Roomify\Bat\Store\DrupalDBStore;
use Roomify\Bat\Unit\Unit;

include_once 'roomify_channel_ical.features.inc';

/**
 * Drupal hook implementations.
 */

/**
 * Implements hook_cron()
 */
function roomify_channel_ical_cron() {
  global $conf;

  // FIXME: only run e.g. every half hour. (configurable?)
  $queue = DrupalQueue::get('roomify_channel_ical');

  // Get all ical source variables.
  foreach (preg_filter('/^roomify_channel_ical_import_url_(\d*)_(\d*)_(.*)/', '$1#$2#$3#$0', array_keys($conf)) as $source) {
    list($property_id, $type_id, $ical_type, $var_name) = explode('#', $source);

    // If a URL is defined for this source, add a task to fetch events.
    if ($ical_url = variable_get($var_name, '')) {
      $queue->createItem(array('property_id' => $property_id, 'type_id' => $type_id, 'ical_type' => $ical_type, 'ical_url' => $ical_url));
    }
  }
}

/**
 * Implements hook_cron_queue_info()
 */
function roomify_channel_ical_cron_queue_info() {
  $queues['roomify_channel_ical'] = array(
    'worker callback' => 'roomify_channel_ical_update_availability',
    'time' => 60,
  );
  return $queues;
}

/**
 * Custom functionality.
 */

/**
 * Access callback - determine if the logged in user has access to administer
 * the given unit.
 */
function roomify_channel_ical_access($type) {
  global $user;

  if (entity_access('update', 'bat_type', $type, $user)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_roomify_channel_connector_channel().
 */
function roomify_channel_ical_roomify_channel_connector_channel($property) {
  $content = drupal_get_form('roomify_channel_ical_admin_form', $property);
  return $content;
}

/**
 * Channel management forms for type channel management tab.
 */
function roomify_channel_ical_admin_form($form, &$form_state, $property) {
  // Load the property and see if it has a single type with a single unit. If
  // not iCal won't work.
  if (count($property->property_bat_type_reference[LANGUAGE_NONE]) > 1) {
    return;
  }
  else {
    // Load the type.
    $bat_type = bat_type_load($property->property_bat_type_reference[LANGUAGE_NONE][0]['target_id']);
    if ($bat_type->type != 'home') {
      return;
    }
  }

  // Retrieve the export url from the connector if we don't have it cached.
  $export_url = variable_get('roomify_channel_ical_export_url_' . $property->property_id, '');
  if (empty($export_url)) {
    $site_id = roomify_channel_connector_get_site_id();
    $cm_export_url = CM_URL . 'ical/export_url/' . $site_id . '/' . $property->property_id . '/' . $bat_type->type_id . '/availability';
    $request = drupal_http_request($cm_export_url);
    if ($request->data) {
      variable_set('roomify_channel_ical_export_url_' . $property->property_id, $request->data);
    }
  }

  $form['ical_export'] = array(
    '#type' => 'fieldset',
    '#title' => t('iCal availability export'),
  );

  $form['ical_export']['export_url'] = array(
    '#title' => t('iCal export link'),
    '#markup' => '<div class="ical-export-link"><h3>iCal export link</h3>' .
                 $export_url . ' (<a href="' . $export_url . '">download ICS file</a>)' .
                 '</div><br />',
  );

  $form['ical_import'] = array(
    '#type' => 'fieldset',
    '#title' => t('iCal availability import'),
  );

  $form['ical_import']['property_id'] = array(
    '#type' => 'hidden',
    '#value' => $property->property_id,
  );

  $form['ical_import']['type_id'] = array(
    '#type' => 'hidden',
    '#value' => $bat_type->type_id,
  );

  if ($ical_providers = _roomify_channel_ical_providers()) {
    foreach ($ical_providers as $type => $info) {
      $form['ical_import']['roomify_channel_ical_import_url_' . $property->property_id . '_' . $bat_type->type_id . '_' .  $type] = array(
        '#type' => 'textfield',
        '#title' => $info->title . ' URL',
        '#description' => t('Enter an iCal URL - availability will be synced from this calendar.'),
        '#maxlength' => 2000,
        '#default_value' => variable_get('roomify_channel_ical_import_url_' . $property->property_id . '_' . $bat_type->type_id . '_' . $type, '') ? variable_get('roomify_channel_ical_import_url_' . $property->property_id . '_' . $bat_type->type_id . '_' . $type) : '',
      );
    }
  }
  else {
    drupal_set_message(t('Unable to retrieve providers, please try again'), 'warning');
  }

  $form['#validate'][] = 'roomify_channel_ical_admin_form_validate';

  return system_settings_form($form);
}

/**
 * Validation handler for ical form.
 */
function roomify_channel_ical_admin_form_validate($form, &$form_state) {
  $ical_providers = _roomify_channel_ical_providers();
  foreach ($ical_providers as $type => $title) {
    $url = $form_state['values']['roomify_channel_ical_import_url_' . $form_state['values']['property_id'] . '_' . $form_state['values']['type_id'] . '_' . $type];

    // Ensure we have a valid absolute URL.
    if (strlen($url) && !valid_url($url, TRUE)) {
      form_set_error('roomify_channel_ical_import_url_' . $form_state['values']['property_id'] . '_' . $form_state['values']['type_id'] . '_' . $type, t('The URL %url is invalid. Enter a fully-qualified URL, such as http://www.example.com/feed.xml.', array('%url' => $url)));
    }
  }
}

/**
 * Cron queue callback - update availability from remote source.
 */
function roomify_channel_ical_update_availability($data) {
  // FIXME: We need logging.

  $site_id = roomify_channel_connector_get_site_id();
  $url = CM_URL . 'ical/import/' . $site_id . '/' . $data['property_id'] . '/' . $data['type_id'] . '/' . $data['ical_type'] . '/' . base64_encode($data['ical_url']);
  $request = drupal_http_request($url);
  if ($request->data) {
    $events = json_decode($request->data);

    // First, delete events that have disappeared from the remote source.
    $eids = array();
    foreach ($events as $event) {
      $eids[] = $event->eid;
    }

    // Get a list of upcoming bookings for this type.

    // For iCal, we can assume that we have a single unit.
    $unit = current(bat_unit_load_multiple(FALSE, array('type_id' => $data['type_id'])));

    $start_date = new \DateTime();

    // Get booking starting today or later for this unit.
    $query = db_select('field_data_event_bat_unit_reference', 'feur');
    $query->join('field_data_booking_event_reference', 'fber', 'feur.entity_id = fber.booking_event_reference_target_id');
    $query->join('field_data_booking_start_date', 'fbsd', 'feur.entity_id = fbsd.entity_id');
    $query->join('field_data_field_ical_type', 'fit', 'fbsd.entity_id = fit.entity_id');

    $query->condition('feur.event_bat_unit_reference_target_id', $unit->unit_id)
          ->condition('fbsd.booking_start_date_value', $start_date->format('Y-m-d 00:00:00'), '>=')
          ->condition('fber.bundle', 'ical')
          ->condition('fit.field_ical_type_value', $data['ical_type'])
          ->fields('fber', array('entity_id'));

    $result = $query->execute();

    $bookings = array();
    foreach ($result as $record) {
      $bookings[] = bat_booking_load($record->entity_id);
    }

    // Delete bookings that no longer exist in the remote source.
    $existing_eids = array();
    foreach ($bookings as $booking) {
      // If eid not present in remote, delete this booking.
      if (!in_array($booking->field_event_id[LANGUAGE_NONE][0]['value'], $eids)) {
        bat_booking_delete($booking);
      }
      else {
        $existing_eids[] = $booking->field_event_id[LANGUAGE_NONE][0]['value'];
      }
    }

    // Now we create any new bookings.
    foreach ($events as $event) {

      // If this event's ID matches an existing event, skip to the next event.
      if (in_array($event->eid, $existing_eids)) {
        continue;
      }

      // If a booking already exists for this unit with these dates, skip to
      // the next event.
      if (roomify_channel_ical_booking_exists($event->startDate, $event->endDate, $unit->unit_id)) {
        continue;
      }

      // If a blocking event conflicts with these dates, skip to the next
      // event.
      // FIXME: tell someone when this happens.
      if (roomify_channel_ical_booking_conflicts($event->startDate, $event->endDate, $unit->unit_id)) {
        continue;
      }

      // We got this far, create the bat event.
      $bat_type = bat_type_load($data['type_id']);
      $bat_event = bat_event_create(array(
        'type'       => 'availability',
        'start_date' => $event->startDate,
        'end_date'   => $event->endDate,
        'uid'        => $bat_type->uid,
        'created'    => REQUEST_TIME,
      ));
      $bat_event->event_bat_unit_reference[LANGUAGE_NONE][0]['target_id'] = $unit->unit_id;
      $state = bat_event_load_state_by_machine_name(BOOKED);
      $bat_event->event_state_reference[LANGUAGE_NONE][0]['state_id'] = $state['id'];
      $bat_event->save();

      // Create the booking.
      $booking = array(
        'type' => 'ical',
        'label' => !empty($event->reservation_name) ? $event->reservation_name : $event->summary,
        'created' => REQUEST_TIME,
        'uid' => $bat_type->uid,
        'booking_start_date'      => array(LANGUAGE_NONE => array(0 => array('value'     => $event->startDate))),
        'booking_end_date'        => array(LANGUAGE_NONE => array(0 => array('value'     => $event->endDate))),
        'booking_event_reference' => array(LANGUAGE_NONE => array(0 => array('target_id' => $bat_event->event_id))),
        'field_event_id'          => array(LANGUAGE_NONE => array(0 => array('value'     => $event->eid))),
        'field_reservation_id'    => array(LANGUAGE_NONE => array(0 => array('value'     => $event->reservation_id))),
        'field_reservation_name'  => array(LANGUAGE_NONE => array(0 => array('value'     => $event->reservation_name))),
        'field_description'       => array(LANGUAGE_NONE => array(0 => array('value'     => $event->description))),
        'field_summary'           => array(LANGUAGE_NONE => array(0 => array('value'     => $event->summary))),
        'field_ical_type'         => array(LANGUAGE_NONE => array(0 => array('value'     => $data['ical_type']))),
      );

      $booking = bat_booking_create($booking);
      $booking->save();

      // Link the event to the booking.
      $bat_event->event_booking_reference[LANGUAGE_NONE][0]['target_id'] = $booking->booking_id;
      $bat_event->save();
    }
  }
}

/**
 * Helper function - check if a booking with the given parameters exists.
 */
function roomify_channel_ical_booking_exists($startDate, $endDate, $unit_id) {
  $query = db_select('field_data_event_bat_unit_reference', 'feur');
  $query->join('field_data_booking_event_reference', 'fber', 'feur.entity_id = fber.booking_event_reference_target_id');
  $query->join('field_data_booking_start_date', 'fbsd', 'fber.entity_id = fbsd.entity_id');
  $query->join('field_data_booking_end_date', 'fbed', 'fber.entity_id = fbed.entity_id');

  $query->condition('feur.event_bat_unit_reference_target_id', $unit_id)
        ->condition('fbsd.booking_start_date_value', $startDate . ' 00:00:00')
        ->condition('fbed.booking_end_date_value', $endDate . ' 00:00:00')
        ->fields('fbsd', array('entity_id'));

  return $query->execute()->rowCount();
}

/**
 * Helper function - check if dates conflict with a blocking event.
 */

function roomify_channel_ical_booking_conflicts($startDate, $endDate, $unit_id) {
  global $databases;

  $prefix = (isset($databases['default']['default']['prefix'])) ? $databases['default']['default']['prefix'] : '';
  $event_store = new DrupalDBStore('availability', DrupalDBStore::BAT_EVENT, $prefix);

  $start_date = new DateTime($startDate);
  $end_date = new DateTime($endDate);
  $end_date->sub(new DateInterval('PT1M'));

  $unit = bat_unit_load($unit_id);
  $bat_units = array(
    new Unit($unit->unit_id, $unit->getEventDefaultValue('availability')),
  );

  $calendar = new Calendar($bat_units, $event_store);
  $events = $calendar->getEvents($start_date, $end_date);

  foreach ($events[$unit->unit_id] as $event) {
    $event_id = $event->getValue();
    if ($event = bat_event_load($event_id)) {
      $state = bat_event_load_state($event->event_state_reference[LANGUAGE_NONE][0]['state_id']);
      if ($state['blocking']) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * List available providers.
 */
function _roomify_channel_ical_providers() {
  $cm_provider_url = CM_URL . 'ical/importers';
  $request = drupal_http_request($cm_provider_url);
  if ($request->data) {
    return json_decode($request->data);
  }
}
